xquery version "3.0";

import module namespace xmldb="http://exist-db.org/xquery/xmldb";
(:import module namespace functx="http://www.functx.com";:)

import module namespace global="http://exist-db.org/apps/cbdb-data/global" at "global.xqm";
import module namespace cal="http://exist-db.org/apps/cbdb-data/calendar" at "calendar.xql";

declare namespace tei="http://www.tei-c.org/ns/1.0";
declare namespace no="http://none";

declare namespace bib="http://exist-db.org/apps/cbdb-data/bibliography";

declare default element namespace "http://www.tei-c.org/ns/1.0";


(:bibliography.xql reads the various basic entities for bibliographic information
    and creates a listBibl element for inclusion in the body element via xi:xinclude.  
listBibl refers to the taxonomy generated by genre.xql.:)

(: TODO: 
    - $TEXT_ROLE_CODES//no:c_role_desno:c_chn is currently dropped from db might go into odd later
    - get all the created by and modified ppl into header as refs
:)


declare function bib:bibl-dates($dates as node()*, $type as xs:string?) as node()* {
(: There are two principle date references in TEXT_CODE. original (ori) and published (pub).
This function resolves the relations of these dates expecting a valid no:c_textid.
It returns both english and chinese dates, refering to  chal_ZH.xml .
:)

(:
(distinct-values($TEXT_CODES//no:c_pub_range_code), distinct-values($TEXT_CODES//no:c_range_code))
shows range 300, and 301 not to be in use, 
we also collapse the distinction between 'during' and "around" to "when"

:)

let $original :=
    for $date in $dates
    let $orig-year := $date/../no:c_text_year
    let $orig-nian := $date/../no:c_text_nh_code/text()
    let $orig-hao := $date/../no:c_text_nh_year/text()
    let $orig-era := $date/../no:c_period/text()    
    
    let $orig-range := $global:YEAR_RANGE_CODES//no:c_range_code[. = $date/../no:c_text_range_code/text()]
    
    where $orig-year[. != 0]
   
    return
        switch ($orig-range)
            case '-1' 
                return <date type="original" notAfter="{cal:isodate ($orig-year)}">
                        {$orig-era}
                            {if ($orig-nian = 0 or empty($orig-nian))
                             then ()
                             else(<ref target="{concat("#R", $orig-nian)}">
                                {$orig-hao}
                             </ref>)
                             }
                         </date>                    
            case '1' 
                return <date type="original" notBefore="{cal:isodate ($orig-year)}">
                        {$orig-era}
                            {if ($orig-nian = 0 or empty($orig-nian))
                             then ()
                             else(<ref target="{concat("#R", $orig-nian)}">
                                {$orig-hao}
                             </ref>)
                             }
                        </date>
             default return 
                        <date type="original" when="{cal:isodate ($orig-year)}">
                            {$orig-era}
                            {if ($orig-nian = 0 or empty($orig-nian))
                            then ()
                            else(<ref target="{concat("#R", $orig-nian)}">
                                {$orig-hao}
                            </ref>)
                            }
                        </date>

let $published := 
    for $date in $dates 
    let $pub-year := $date/../no:c_pub_year    
    
    let $pub-nian := $date/../no:c_pub_nh_code/text()
    let $pub-hao := $date/../no:c_pub_nh_year/text()
    
    let $pub-era := $date/../no:c_pub_dy
    
    let $pub-range := $global:YEAR_RANGE_CODES//no:c_range_code[. = $date/../no:c_pub_range_code/text()]
    where $pub-year[. != 0]
   
    return
        switch ($pub-range)
            case '-1' 
                return <date type="published" notAfter="{cal:isodate ($pub-year)}">
                        {if ($pub-era[. = 0]) then ()
                        else(<ref target="{concat("#D", $pub-era)}"/>)
                        }
                            {if ($pub-nian = 0 or empty($pub-nian))
                             then ()
                             else(<ref target="{concat("#R", $pub-nian)}">
                                {$pub-hao}
                             </ref>)
                             }
                         </date>                    
            case '1' 
                return <date type="published" notBefore="{cal:isodate ($pub-year)}">
                        {if ($pub-era[. = 0]) then ()
                        else(<ref target="{concat("#D", $pub-era)}"/>)
                        }
                            {if ($pub-nian = 0 or empty($pub-nian))
                             then ()
                             else(<ref target="{concat("#R", $pub-nian)}">
                                {$pub-hao}
                             </ref>)
                             }
                        </date>
             default return 
                        <date type="published" when="{cal:isodate ($pub-year)}">
                            {if ($pub-era[. = 0]) then ()
                            else(<ref target="{concat("#D", $pub-era)}"/>)
                            }
                            {if ($pub-nian = 0 or empty($pub-nian))
                            then ()
                            else(<ref target="{concat("#R", $pub-nian)}">
                                    {$pub-hao}
                                  </ref>)
                            }
                        </date>
return
    switch($type)
        case 'ori' return $original
        case 'pub' return $published
    default return ()

};

declare function bib:roles ($roles as node()*)  as node()* {

(:this function takes in no:c_role_id from TEXT_DATA and returns suitable TEI elements for each.
It simplifies no:c_role_id[. = 11] 'work included in' to 'contributor' and drops the chinese role terms.
These could be added back in later via a translation of the tei schema file.
:)

for $role in $roles
let $code :=  $global:TEXT_ROLE_CODES//no:c_role_id[. = $role]
let $bio-id := $role/../no:c_personid
where $bio-id != 0

return
    switch($role)
        case '0' case '2' return <editor><ptr target="{concat('#BIO', $bio-id)}"/></editor>
        case '1' return <author><ptr target="{concat('#BIO', $bio-id)}"/></author>
        case '4' return <publisher><ptr target="{concat('#BIO', $bio-id)}"/></publisher>   
        case '11' return <editor role="contributor"><ptr target="{concat('#BIO', $bio-id)}"/></editor>
    default return <editor role="{$code/../no:c_role_desc}"><ptr target="{concat('#BIO', $bio-id)}"/></editor>

};

declare function bib:bibliography ($texts as node()*) {

(:This function reads the entities in TEXT_CODES [sic] and generates corresponding tei:bibl elements:)

for $text in $texts

let $role := $global:TEXT_DATA//no:c_textid[ . = $text]/../no:c_role_id

let $cat  := $global:TEXT_BIBLCAT_CODES//no:c_text_cat_code[. =  $text/../no:c_bibl_cat_code/text()]
let $type := $global:TEXT_TYPE//no:c_text_type_code[. =$text/../no:c_text_type_id/text()]

let $extant := $global:EXTANT_CODES//no:c_extant_code[. = $text/../no:c_extant/text()]
let $country := $global:COUNTRY_CODES//no:c_country_code[. = $text/../no:c_pub_country/text()]
let $txtcountry :=  $global:COUNTRY_CODES//no:c_country_code[. = $text/../no:c_text_country]


(: d= drop
[tts_sysno] INTEGER,                     x
 [no:c_textid] INTEGER PRIMARY KEY,       x
 [no:c_title_chn] CHAR(255),               x
 [no:c_suffix_version] CHAR(255),         x
 [no:c_title] CHAR(255),                    x
 [no:c_title_trans] CHAR(255),             x
 [no:c_text_type_id] INTEGER,              x        
 [no:c_text_year] INTEGER,                 x
 [no:c_text_nh_code] INTEGER,              x
 [no:c_text_nh_year] INTEGER,              x
 [no:c_text_range_code] INTEGER,          x
 [no:c_period] CHAR(255),                  x
 [no:c_bibl_cat_code] INTEGER,            x     
 [no:c_extant] INTEGER,                    x
 [no:c_text_country] INTEGER,             x 
 [no:c_text_dy] INTEGER,                   x
 [no:c_pub_country] INTEGER,              x
 [no:c_pub_dy] INTEGER,                    x
 [no:c_pub_year] CHAR(50),                 x
 [no:c_pub_nh_code] INTEGER,               x   
 [no:c_pub_nh_year] INTEGER,               x
 [no:c_pub_range_code] INTEGER,            x
 [no:c_pub_loc] CHAR(255),                  x
 [no:c_publisher] CHAR(255),               x
 [no:c_pub_notes] CHAR(255),               x
 [no:c_source] INTEGER,                     x
 [no:c_pages] CHAR(255),                    x
 [no:c_url_api] CHAR(255),                  x
 [no:c_url_homepage] CHAR(255),            x
 [no:c_notes] CHAR,                          x
 [no:c_number] CHAR(255),                   x
 [no:c_counter] CHAR(255),                  x
 [no:c_title_alt_chn] CHAR(255),           x
 [no:c_created_by] CHAR(255),              x
 [no:c_created_date] CHAR(255),            x
 [no:c_modified_by] CHAR(255),             x
 [no:c_modified_date] CHAR(255))           x
 :)


return
    global:validate-fragment(
    element bibl { attribute xml:id{concat("BIB", $text/text())},
    if ($type > 0 and $cat > 0)
    then (attribute type {concat("#biblType", $type/text())}, 
           attribute subtype {concat("#biblCat", $cat/text())})
    else if ($type > 0)
          then (attribute type {concat("#biblType", $cat/text())})
          else if ($cat > 0)
                then (attribute type {concat("#biblCat", $cat/text())})
                else (), 
    
        if (empty($text/../no:tts_sysno))
        then ()
        else(<idno type="TTS">{$text/../no:tts_sysno/text()}</idno>),
        
        <title type="main">
                <title xml:lang="zh-Hant">{$text/../no:c_title_chn/text()}</title>
                <title xml:lang="zh-Latn-alalc97">{$text/../no:c_title/text()}</title>
        </title>,
        
        if (empty($text/../no:c_title_alt_chn))
        then ()
        else (<title type="alt">{$text/../no:c_title_alt_chn/text()}</title>),        
        
        if (empty($text/../no:c_title_trans))
        then ()
        else (<title xml:lang="en" type="translation">{$text/../no:c_title_trans/text()}</title>),        
        
        if (empty($text/../no:c_text_year))
        then ()
        else (bib:bibl-dates($text, 'ori')),        
        
        if (empty($text/../no:c_text_country) or $text/../no:c_text_country[. = 0]) 
        then ()
        else ( <country xml:lang="zh-Hant">{$txtcountry/../no:c_country_desc_chn/text()}</country>,
                <country xml:lang="en">{$txtcountry/../no:c_country_desc/text()}</country>), 
        
        if (empty($text/../no:c_suffix_version))
        then ()
        else (<edition>{$text/../no:c_suffix_version/text()}</edition>),
        
        if (empty($text/../no:c_publisher))
        then ()
        else (<publisher>{$text/../no:c_publisher/text()}</publisher>), 
        
        if (empty($text/../no:c_pub_loc))
        then ()
        else (<pubPlace>{$text/../no:c_pub_loc/text()}</pubPlace>), 
        
        if (empty($country) or $country[. = 0])
        then ()
        else (<pubPlace><country>{$country/../no:c_country_desc/text()}</country></pubPlace>),
        
        if (empty($text/../no:c_pub_year))
        then ()
        else (bib:bibl-dates($text, 'pub')),        
        
        if (empty($text/../no:c_extant))
        then ()
        else (<state><ab>{$extant/../no:c_extant_desc/text()}</ab></state>),        
        
        if (empty($text/../no:c_pub_notes) or $text/../no:c_pub_notes[. = '-1'])
        then ()
        else (<note>{$text/../no:c_pub_notes/text()}</note>), 
        
        if (empty($text/../no:c_source) or $text/../no:c_source[. < 1])
        then ()
        else (<bibl>
                <ref target="{concat('#BIB', $text/../no:c_source/text())}"/>
                {
                if (empty($text/../no:c_pages)) then ()
                else(<biblScope unit="page">{$text/../no:c_pages/text()}</biblScope>)
                }
                {
                if (empty($text/../no:c_number)) then () 
                else (<biblScope>{$text/../no:c_number/text()} {$text/../no:c_counter/text()}</biblScope>)
                }                
              </bibl>), 
        
        if (empty($role))
        then()
        else (bib:roles($role)),
        
        if (empty($text/../no:c_url_api))
        then ()
        else (<ref target="{$text/../no:c_url_api/text()}">
            {$text/../no:c_url_homepage/text()}
            </ref>),       
        
        if (empty($text/../no:c_notes))
        then ()
        else(<note>{$text/../no:c_notes/text()}</note>),
        
        global:create-mod-by($text/../no:c_created_by, $text/../no:c_modified_by)
        },'bibl')
};

(:2188.5s:)

xmldb:store($global:target, $global:bibliography,

 <listBibl>{
        bib:bibliography($global:TEXT_CODES//no:c_textid[. > 0])
 }</listBibl>    
) 




