xquery version "3.0";

(:~
 : The bibliography module transforms core bibliographic data from CBDB into TEI. 
 : It's output references the taxonomy generated by the genre module. 
 : It's elements are frequently referenced by source attributes across the whole data set.
 : 
 : @author Duncan Paterson
 : @version 0.7
 : @see #genre
 :
 : @return listBibl.xml:)

module namespace bib="http://exist-db.org/apps/cbdb-data/bibliography";

(:import module namespace functx="http://www.functx.com";:)
import module namespace xmldb="http://exist-db.org/xquery/xmldb";
import module namespace global="http://exist-db.org/apps/cbdb-data/global" at "global.xqm";
import module namespace cal="http://exist-db.org/apps/cbdb-data/calendar" at "calendar.xql";

declare namespace test="http://exist-db.org/xquery/xqsuite";
declare namespace tei="http://www.tei-c.org/ns/1.0";
declare namespace no="http://none";

declare default element namespace "http://www.tei-c.org/ns/1.0";


declare 
    %test:pending("fragment")
function bib:bibl-dates($dates as node()*, $type as xs:string?) as node()* {
(:~ 
 : bib:bibl-dates reads the two principle date references in TEXT_CODE: original and published.
 : This function resolves the relations of these dates expecting a valid no:c_textid.
 : It returns both english and Chinese dates, referring to chal_ZH.xml.
 :
 : @param $dates is a c_textid
 : @param $type can take either 'ori' for original, or 'pub' for published dates.
 : 
 : @return date normalizes the distinction between 'during' and "around" to "when":)

let $original :=
    for $date in $dates
    let $orig-year := $date/../no:c_text_year
    let $orig-nian := $date/../no:c_text_nh_code/text()
    let $orig-hao := $date/../no:c_text_nh_year/text()
    let $orig-dy := $date/../no:c_period/text()    
    
    let $orig-range := $global:YEAR_RANGE_CODES//no:c_range_code[. = $date/../no:c_text_range_code/text()]
    
    where $orig-year[. != 0]
   
    return
        switch ($orig-range)
            case '-1' 
                return <date type="original" notAfter="{cal:isodate ($orig-year)}">
                        {$orig-dy}
                            {if ($orig-nian = 0 or empty($orig-nian))
                             then ()
                             else(<ref target="{concat("#R", $orig-nian)}">
                                {$orig-hao}
                             </ref>)
                             }
                         </date>                    
            case '1' 
                return <date type="original" notBefore="{cal:isodate ($orig-year)}">
                        {$orig-dy}
                            {if ($orig-nian = 0 or empty($orig-nian))
                             then ()
                             else(<ref target="{concat("#R", $orig-nian)}">
                                {$orig-hao}
                             </ref>)
                             }
                        </date>
             default return 
                        <date type="original" when="{cal:isodate ($orig-year)}">
                            {$orig-dy}
                            {if ($orig-nian = 0 or empty($orig-nian))
                            then ()
                            else(<ref target="{concat("#R", $orig-nian)}">
                                {$orig-hao}
                            </ref>)
                            }
                        </date>

let $published := 
    for $date in $dates 
    let $pub-year := $date/../no:c_pub_year    
    
    let $pub-nian := $date/../no:c_pub_nh_code/text()
    let $pub-hao := $date/../no:c_pub_nh_year/text()
    
    let $pub-dy := $date/../no:c_pub_dy
    
    let $pub-range := $global:YEAR_RANGE_CODES//no:c_range_code[. = $date/../no:c_pub_range_code/text()]
    where $pub-year[. != 0]
   
    return
        switch ($pub-range)
            case '-1' 
                return <date type="published" notAfter="{cal:isodate ($pub-year)}">
                        {if ($pub-dy[. = 0]) then ()
                        else(<ref target="{concat("#D", $pub-dy)}"/>)
                        }
                            {if ($pub-nian = 0 or empty($pub-nian))
                             then ()
                             else(<ref target="{concat("#R", $pub-nian)}">
                                {$pub-hao}
                             </ref>)
                             }
                         </date>                    
            case '1' 
                return <date type="published" notBefore="{cal:isodate ($pub-year)}">
                        {if ($pub-dy[. = 0]) then ()
                        else(<ref target="{concat("#D", $pub-dy)}"/>)
                        }
                            {if ($pub-nian = 0 or empty($pub-nian))
                             then ()
                             else(<ref target="{concat("#R", $pub-nian)}">
                                {$pub-hao}
                             </ref>)
                             }
                        </date>
             default return 
                        <date type="published" when="{cal:isodate ($pub-year)}">
                            {if ($pub-dy[. = 0]) then ()
                            else(<ref target="{concat("#D", $pub-dy)}"/>)
                            }
                            {if ($pub-nian = 0 or empty($pub-nian))
                            then ()
                            else(<ref target="{concat("#R", $pub-nian)}">
                                    {$pub-hao}
                                  </ref>)
                            }
                        </date>
return
    switch($type)
        case 'ori' return $original
        case 'pub' return $published
    default return ()

};

declare 
    %test:pending("fragment")
function bib:roles ($roles as node()*)  as node()* {
(:~ 
 : bib:roles reads c_role_id from TEXT_DATA, and TEXT_ROLE_CODES to transform into matching TEI elements.
 : It simplifies ``c_role_id[. = 11] 'work included in'`` to ``contributor``.
 : it currently drops the Chinese terms from ``$TEXT_ROLE_CODES//no:c_role_desc_chn`.
 : These could be added back in later via a ODD. 
 : 
 : @param $roles is a c_role_id
 :
 : @return author, editor, or publisher with references to listPerson.:)

(: distinct-values(($TEXT_CODES//no:c_pub_range_code, $TEXT_CODES//no:c_range_code)) 
 : shows range 300, and 301 not to be in use. :)

for $role in $roles
let $code :=  $global:TEXT_ROLE_CODES//no:c_role_id[. = $role]
let $bio-id := $role/../no:c_personid
where $bio-id != 0

return
    switch($role)
        case '0' case '2' return <editor ref="{concat('#BIO', $bio-id)}"/>
        case '1' return <author ref="{concat('#BIO', $bio-id)}"/>
        case '4' return <publisher ref="{concat('#BIO', $bio-id)}"/>  
        case '11' return <editor role="contributor" ref="{concat('#BIO', $bio-id)}"/>
    default return <editor role="{$code/../no:c_role_desc}" ref="{concat('#BIO', $bio-id)}"/>
};

declare 
    %test:pending("validation as test")
function bib:bibliography ($texts as node()*, $mode as xs:string?) as item()*{
(:~
 : This function reads the entities in TEXT_CODES ``sic`` and generates corresponding bibl elements, joining
 : data from TEXT_DATA, TEXT_BIBLCAT_CODES, TEXT_TYPE, EXTANT_CODES, and COUNTRY_CODES. 
 : 
 : @param $texts is a c_textid
 : @param $mode can take three effective values:
 :    *   'v' = validate; preforms a validation of the output before passing it on. 
 :    *   ' ' = normal; runs the transformation without validation.
 :    *   'd' = debug; this is the slowest of all modes.  
 : 
 : @return ``<bibl id="BIB...">...</bib>``:)

let $output := 

    for $text in $texts
    
    let $role := $global:TEXT_DATA//no:c_textid[ . = $text]/../no:c_role_id    
    let $cat  := $global:TEXT_BIBLCAT_CODES//no:c_text_cat_code[. =  $text/../no:c_bibl_cat_code/text()]
    let $type := $global:TEXT_TYPE//no:c_text_type_code[. =$text/../no:c_text_type_id/text()]
    
    let $extant := $global:EXTANT_CODES//no:c_extant_code[. = $text/../no:c_extant/text()]
    let $country := $global:COUNTRY_CODES//no:c_country_code[. = $text/../no:c_pub_country/text()]
    let $txtcountry :=  $global:COUNTRY_CODES//no:c_country_code[. = $text/../no:c_text_country/text()]
    
    order by number($text/../no:c_textid)
    return    
        element bibl { attribute xml:id{concat("BIB", $text/text())},
        if ($type > 0 and $cat > 0)
        then (attribute type {concat("#biblType", $type/text())}, 
               attribute subtype {concat("#biblCat", $cat/text())})
        else if ($type > 0)
              then (attribute type {concat("#biblType", $cat/text())})
              else if ($cat > 0)
                    then (attribute type {concat("#biblCat", $cat/text())})
                    else (), 
        for $n in $text/../*[. != '0'][. != '-1']
        order by local-name($n) descending
        return 
            typeswitch($n)
                case element (no:tts_sysno) return element idno { attribute type {'TTS'}, $n/text()}
                case element (no:c_title_chn) return element title { attribute type {'main'}, attribute xml:lang {'zh-Hant'}, $n/text()}
                case element (no:c_title) return element title { attribute type {'main'}, attribute xml:lang {'zh-Latn-alalc97'}, $n/text()}
                case element (no:c_title_alt_chn) return element title { attribute type {'alt'}, $n/text()}
                case element (no:c_title_trans) return element title { attribute type {'translation'}, attribute xml:lang {'en'}, $n/text()}
                case element (no:c_text_year) return bib:bibl-dates($text, 'ori')
                case element (no:c_pub_year) return bib:bibl-dates($text, 'pub')
                case element (no:c_text_country) return 
                        (element country { attribute xml:lang {'zh-Hant'}, $txtcountry/../no:c_country_desc_chn/text()},
                         element country { attribute xml:lang {'en'}, $txtcountry/../no:c_country_desc/text()})
                case element (no:c_pub_country) return element pubPlace { element country {$country/../no:c_country_desc/text()}}         
                case element (no:c_suffix_version) return element edition {$n/text()}
                case element (no:c_publisher) return element publisher {$n/text()}
                case element (no:c_pub_loc) return element pubPlace {$n/text()}
                case element (no:c_extant) return element state { element ab {$extant/../no:c_extant_desc/text()}}
                case element (no:c_pub_notes) return element note {$n/text()}
                case element (no:c_source) return element bibl { 
                    element ref { attribute target {concat('#BIB', $n/text())}},
                    if (empty($text/../no:c_pages)) 
                    then ()
                    else (element biblScope { attribute unit {'page'}, $text/../no:c_pages/text()}), 
                    
                    if (empty($text/../no:c_number)) 
                    then ()
                    else (element biblScope {concat($text/../no:c_number/text(), $text/../no:c_counter/text())})
                    }
                case element (no:c_url_api) return element ref { attribute target {$n/text()}, $text/../no:c_url_homepage/text()} 
                case element (no:c_notes) return element note {$n/text()}              
            default return (),
            
            if (empty($role))
            then ()
            else (bib:roles($role)),
            
            global:create-mod-by($text/../no:c_created_by, $text/../no:c_modified_by)
        }
        
return 
    switch($mode)
        case 'v' return global:validate-fragment($output, 'bibl')
        case 'd' return global:validate-fragment($output, 'bibl')[1]
    default return $output
};

(: 2188.5s :)
declare %private function bib:write ($item as item()*) as item() {
xmldb:store($global:target, $global:bibliography,

 <listBibl>{
        bib:bibliography($global:TEXT_CODES//no:c_textid[. > 0], 'v')
 }</listBibl>    
)}; 




