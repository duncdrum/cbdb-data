(:Somewhat normalised map of nianhao transliterations, better use wikipedia or something else:)

let $NH-py := map{
 '白龍' := 'bailong',
 '白雀' := 'baique',
 '寶大' := 'baoda',
 '保大' := 'baoda',
 '寶鼎' := 'baoding',
 '保定' := 'baoding',
 '寶曆' := 'baoli',
 '保寧' := 'baoning',
 '寶慶' := 'baoqing',
 '寶太(寶大)' := 'baotai',
 '寶義' := 'baoyi',
 '寶應' := 'baoying',
 '寶祐' := 'baoyou',
 '寶元' := 'baoyuan',
 '寶貞(寶正)' := 'baozhen',
 '保貞(寶正)' := 'baozhen',
 '寶正' := 'baozheng',
 '本初' := 'benchu',
 '本始' := 'benshi',
 '長安' := 'changan',
 '長樂' := 'changle',
 '長慶' := 'changqing',
 '長壽' := 'changshou',
 '昌武' := 'changwu',
 '長興' := 'changxing',
 '承安' := 'chengan',
 '承光' := 'chengguang',
 '成化' := 'chenghua',
 '承明' := 'chengming',
 '承平' := 'chengping',
 '承聖' := 'chengsheng',
 '赤烏' := 'chiwu',
 '崇德' := 'chongde',
 '崇福' := 'chongfu',
 '崇寧' := 'chongning',
 '崇慶' := 'chongqing',
 '崇禎' := 'chongzhen',
 '垂拱' := 'chuigong',
 '淳化' := 'chunhua',
 '淳熙' := 'chunxi',
 '淳祐' := 'chunyou',
 '初平' := 'chuping',
 '初始' := 'chushi',
 '初元' := 'chuyuan',
 '大安' := 'daAn',
 '大寶' := 'dabao',
 '大成' := 'dacheng',
 '大德' := 'dade',
 '大定' := 'dading',
 '大觀' := 'daguan',
 '大和' := 'dahe',
 '大曆' := 'dali',
 '大明' := 'daming',
 '大慶' := 'daqing',
 '大順' := 'dashun',
 '大通' := 'datong',
 '大同' := 'datong',
 '大統' := 'datong',
 '大象' := 'daxiang',
 '大業' := 'daye',
 '大有' := 'dayou',
 '大中' := 'dazhong',
 '大足' := 'dazu',
 '地節' := 'dejie',
 '登國' := 'dengguo',
 '德祐' := 'deyou',
 '調露' := 'diaolu',
 '地皇' := 'dihuang',
 '定宗' := 'dingzong',
 '端拱' := 'duangong',
 '端平' := 'duanping',
 '奲都' := 'duodou',
 '鳳凰' := 'fenghuang',
 '鳳翔' := 'fengxiang',
 '阜昌' := 'fuchang',
 '甘露' := 'ganlu',
 '更始' := 'gengshi',
 '拱化' := 'gonghua',
 '光初' := 'guangchu',
 '光大' := 'guangda',
 '廣大(光大)' := 'guangda',
 '廣德' := 'guangde',
 '光定' := 'guangding',
 '光和' := 'guanghe',
 '光化' := 'guanghua',
 '廣明' := 'guangming',
 '光啟' := 'guangqi',
 '光始' := 'guangshi',
 '光壽' := 'guangshou',
 '廣順' := 'guangshun',
 '光天(光大)' := 'guangtian',
 '光天' := 'guangtian',
 '光熹' := 'guangxi',
 '光熙' := 'guangxi',
 '光興' := 'guangxing',
 '光緒' := 'guangxu',
 '廣運' := 'guangyun',
 '光宅' := 'guangzhai',
 '廣政' := 'guangzheng',
 '海迷失后' := 'haimishihou',
 '漢安' := 'hanan',
 '河平' := 'heping',
 '和平' := 'heping',
 '河清' := 'heqing',
 '河瑞' := 'herui',
 '弘昌' := 'hongchang',
 '弘道' := 'hongdao',
 '弘光' := 'hongguang',
 '鴻嘉' := 'hongjia',
 '弘始' := 'hongshi',
 '洪武' := 'hongwu',
 '洪熙' := 'hongxi',
 '弘治' := 'hongzhi',
 '後元' := 'houyuan',
 '黃初' := 'huangchu',
 '皇初' := 'huangchu',
 '皇建' := 'huangjian',
 '黃龍' := 'huanglong',
 '皇慶' := 'huangqing',
 '皇始' := 'huangshi',
 '皇統' := 'huangtong',
 '黃武' := 'huangwu',
 '皇興' := 'huangxing',
 '皇祐' := 'huangyou',
 '會昌' := 'huichang',
 '會同' := 'huitong',
 '嘉定' := 'jiading',
 '嘉禾' := 'jiahe',
 '嘉靖' := 'jiajing',
 '建安' := 'jianan',
 '建初' := 'jianchu',
 '建德' := 'jiande',
 '建光' := 'jianguang',
 '建和' := 'jianhe',
 '建衡' := 'jianheng',
 '建弘' := 'jianhong',
 '嘉寧' := 'jianing',
 '建康' := 'jiankang',
 '建隆' := 'jianlong',
 '建明' := 'jianming',
 '建寧' := 'jianning',
 '建平' := 'jianping',
 '建始' := 'jianshi',
 '建文' := 'jianwen',
 '建武' := 'jianwu',
 '建熙' := 'jianxi',
 '建興' := 'jianxing',
 '建炎' := 'jianyan',
 '建義' := 'jianyi',
 '建元' := 'jianyuan',
 '建昭' := 'jianzhao',
 '建中' := 'jianzhong',
 '交泰' := 'jiaotai',
 '嘉平' := 'jiaping',
 '嘉慶' := 'jiaqing',
 '嘉泰' := 'jiatai',
 '嘉熙' := 'jiaxi',
 '嘉興' := 'jiaxing',
 '嘉祐' := 'jiayou',
 '景初' := 'jingchu',
 '景德' := 'jingde',
 '景定' := 'jingding',
 '景福' := 'jingfu',
 '景和' := 'jinghe',
 '靖康' := 'jingkang',
 '景龍' := 'jinglong',
 '景明' := 'jingming',
 '竟寧' := 'jingning',
 '景平' := 'jingping',
 '景泰' := 'jingtai',
 '景炎' := 'jingyan',
 '景耀' := 'jingyao',
 '景祐' := 'jingyou',
 '景元' := 'jingyuan',
 '景雲' := 'jingyun',
 '久視' := 'jiushi',
 '居攝' := 'jushe',
 '開寶' := 'kaibao',
 '開成' := 'kaicheng',
 '開皇' := 'kaihuang',
 '開明' := 'kaiming',
 '開平' := 'kaiping',
 '開慶' := 'kaiqing',
 '開泰' := 'kaitai',
 '開禧' := 'kaixi',
 '開興' := 'kaixing',
 '開耀' := 'kaiyao',
 '開元' := 'kaiyuan',
 '開運' := 'kaiyun',
 '康定' := 'kangding',
 '康國' := 'kangguo',
 '康熙' := 'kangxi',
 '麟德' := 'linde',
 '麟嘉' := 'linjia',
 '隆安' := 'longan',
 '隆昌' := 'longchang',
 '龍德' := 'longde',
 '龍飛' := 'longfei',
 '隆和' := 'longhe',
 '隆化' := 'longhua',
 '龍紀' := 'longji',
 '龍啟' := 'longqi',
 '隆慶' := 'longqing',
 '龍昇' := 'longsheng',
 '龍朔' := 'longshuo',
 '隆武' := 'longwu',
 '隆興' := 'longxing',
 '明昌' := 'mingchang',
 '明道' := 'mingdao',
 '明德' := 'mingde',
 '寧康' := 'ningkang',
 '普泰' := 'putai',
 '普通' := 'putong',
 '乾道' := 'qiandao',
 '乾德' := 'qiande',
 '乾定' := 'qianding',
 '乾封' := 'qianfeng',
 '乾符' := 'qianfu',
 '乾和' := 'qianhe',
 '乾亨' := 'qianheng',
 '乾化' := 'qianhua',
 '乾隆' := 'qianlong',
 '乾明' := 'qianming',
 '乾寧' := 'qianning',
 '乾統' := 'qiantong',
 '乾興' := 'qianxing',
 '乾祐' := 'qianyou',
 '乾元' := 'qianyuan',
 '乾貞' := 'qianzhen',
 '乾正' := 'qianzheng',
 '慶曆' := 'qingli',
 '青龍' := 'qinglong',
 '清寧' := 'qingning',
 '清泰' := 'qingtai',
 '慶元' := 'qingyuan',
 '人慶' := 'renqing',
 '仁壽' := 'renshou',
 '如意' := 'ruyi',
 '上元' := 'shangyuan',
 '紹定' := 'shaoding',
 '紹聖' := 'shaosheng',
 '紹泰' := 'shaotai',
 '紹武' := 'shaowu',
 '紹熙' := 'shaoxi',
 '紹興' := 'shaoxing',
 '神冊' := 'shence',
 '神鼎' := 'shending',
 '神鳳' := 'shenfeng',
 '聖曆' := 'shengli',
 '昇明' := 'shengming',
 '神功' := 'shengong',
 '升平' := 'shengping',
 '神龜' := 'shengui',
 '昇元' := 'shengyuan',
 '神麚' := 'shenjia',
 '神爵' := 'shenjue',
 '神龍' := 'shenlong',
 '神瑞' := 'shenrui',
 '神璽' := 'shenxi',
 '始光' := 'shiguang',
 '始建國' := 'shijianguo',
 '始元' := 'shiyuan',
 '壽昌' := 'shouchang',
 '壽光' := 'shouguang',
 '收國' := 'shouguo',
 '順義' := 'shunyi',
 '嗣聖' := 'sisheng',
 '綏和' := 'suihe',
 '太安' := 'taian',
 '泰常' := 'taichang',
 '太昌' := 'taichang',
 '泰昌' := 'taichang',
 '太初' := 'taichu',
 '泰定' := 'taiding',
 '太和' := 'taihe',
 '泰和' := 'taihe',
 '太極' := 'taiji',
 '太建' := 'taijian',
 '太康' := 'taikang',
 '太寧' := 'taining',
 '太平' := 'taiping',
 '太清' := 'taiqing',
 '太上' := 'taishang',
 '太始' := 'taishi',
 '泰始' := 'taishi',
 '太熙' := 'taixi',
 '太興' := 'taixing',
 '太延' := 'taiyan',
 '泰豫' := 'taiyu',
 '太元' := 'taiyuan',
 '太宗' := 'taizong',
 '太祖' := 'taizu',
 '唐隆' := 'tanglong',
 '天安' := 'tianan',
 '天保' := 'tianbao',
 '天寶' := 'tianbao',
 '天成' := 'tiancheng',
 '天盛' := 'tiancheng',
 '天賜' := 'tianci',
 '天聰' := 'tiancong',
 '天德' := 'tiande',
 '天鳳' := 'tianfeng',
 '天復' := 'tianfu',
 '天福' := 'tianfu',
 '天輔' := 'tianfu',
 '天光' := 'tianguang',
 '天漢' := 'tianhan',
 '天和' := 'tianhe',
 '天會' := 'tianhui',
 '天紀' := 'tianji',
 '天嘉' := 'tianjia',
 '天監' := 'tianjian',
 '天眷' := 'tianjuan',
 '天康' := 'tiankang',
 '天曆' := 'tianli',
 '天祿' := 'tianlu',
 '天命' := 'tianming',
 '天平' := 'tianping',
 '天啟' := 'tianqi',
 '天慶' := 'tianqing',
 '天聖' := 'tiansheng',
 '天授' := 'tianshou',
 '天順' := 'tianshun',
 '天統' := 'tiantong',
 '天璽' := 'tianxi',
 '天禧' := 'tianxi',
 '天顯' := 'tianxian',
 '天興' := 'tianxing',
 '天鍹' := 'tianxuan',
 '天祐' := 'tianyou',
 '天贊' := 'tianzan',
 '天正' := 'tianzheng',
 '天祚' := 'tianzuo',
 '同光' := 'tongguang',
 '統和' := 'tonghe',
 '通文' := 'tongwen',
 '通正' := 'tongzheng',
 '同治' := 'tongzhi',
 '萬曆' := 'wanli',
 '未詳' := 'weixiang',
 '文德' := 'wende',
 '文明' := 'wenming',
 '武成' := 'wucheng',
 '武德' := 'wude',
 '武定' := 'wuding',
 '五鳳' := 'wufeng',
 '武平' := 'wuping',
 '武泰' := 'wutai',
 '武義' := 'wuyi',
 '道光' := 'xaoguang',
 '咸安' := 'xianan',
 '咸淳' := 'xianchun',
 '顯道' := 'xiandao',
 '顯德' := 'xiande',
 '咸豐' := 'xianfeng',
 '祥興' := 'xiangxing',
 '咸和' := 'xianhe',
 '咸亨' := 'xianheng',
 '咸康' := 'xiankang',
 '咸寧' := 'xianning',
 '咸平' := 'xianping',
 '顯慶' := 'xianqing',
 '咸清' := 'xianqing',
 '先天' := 'xiantian',
 '咸通' := 'xiantong',
 '咸熙' := 'xianxi',
 '咸雍' := 'xianyong',
 '憲宗' := 'xianzong',
 '孝昌' := 'xiaochang',
 '孝建' := 'xiaojian',
 '興安' := 'xingan',
 '興定' := 'xingding',
 '興光' := 'xingguang',
 '興和' := 'xinghe',
 '興寧' := 'xingning',
 '興平' := 'xingping',
 '興元' := 'xingyuan',
 '熙寧' := 'xining',
 '熹平' := 'xiping',
 '熙平' := 'xiping',
 '宣德' := 'xuande',
 '宣光' := 'xuanguang',
 '宣和' := 'xuanhe',
 '玄始' := 'xuanshi',
 '宣統' := 'xuantong',
 '宣政' := 'xuanzheng',
 '延昌' := 'yanchang',
 '陽嘉' := 'yangjia',
 '陽朔' := 'yangshuo',
 '延光' := 'yanguang',
 '延和' := 'yanhe',
 '延康' := 'yankang',
 '延平' := 'yanping',
 '晏平' := 'yanping',
 '燕平' := 'yanping',
 '延慶' := 'yanqing',
 '延熹' := 'yanxi',
 '延熙' := 'yanxi',
 '炎興' := 'yanxing',
 '延興' := 'yanxing',
 '燕興' := 'yanxing',
 '延祐' := 'yanyou',
 '燕元' := 'yanyuan',
 '延載' := 'yanzai',
 '儀鳳' := 'yifeng',
 '義和' := 'yihe',
 '應曆' := 'yingli',
 '應乾' := 'yingqian',
 '應順' := 'yingshun',
 '應天' := 'yingtian',
 '義寧' := 'yining',
 '義熙' := 'yixi',
 '永安' := 'yongan',
 '永昌' := 'yongchang',
 '永初' := 'yongchu',
 '永淳' := 'yongchun',
 '永定' := 'yongding',
 '永鳳' := 'yongfeng',
 '永光' := 'yongguang',
 '永漢' := 'yonghan',
 '永和' := 'yonghe',
 '永弘' := 'yonghong',
 '永徽' := 'yonghui',
 '永嘉' := 'yongjia',
 '永建' := 'yongjian',
 '永康' := 'yongkang',
 '永樂' := 'yongle',
 '永曆' := 'yongli',
 '永隆' := 'yonglong',
 '永明' := 'yongming',
 '永寧' := 'yongning',
 '雍寧' := 'yongning',
 '永平' := 'yongping',
 '永始' := 'yongshi',
 '永壽' := 'yongshou',
 '永泰' := 'yongtai',
 '永喜' := 'yongxi',
 '永熙' := 'yongxi',
 '雍熙' := 'yongxi',
 '永興' := 'yongxing',
 '永元' := 'yongyuan',
 '永貞' := 'yongzhen',
 '雍正' := 'yongzheng',
 '元初' := 'yuanchu',
 '元德' := 'yuande',
 '元鼎' := 'yuanding',
 '元封' := 'yuanfeng',
 '元鳳' := 'yuanfeng',
 '元豐' := 'yuanfeng',
 '元符' := 'yuanfu',
 '元光' := 'yuanguang',
 '元和' := 'yuanhe',
 '元徽' := 'yuanhui',
 '元嘉' := 'yuanjia',
 '元康' := 'yuankang',
 '元平' := 'yuanping',
 '元始' := 'yuanshi',
 '元狩' := 'yuanshou',
 '元壽' := 'yuanshou',
 '元朔' := 'yuanshuo',
 '元統' := 'yuantong',
 '元熙' := 'yuanxi',
 '元璽' := 'yuanxi',
 '元象' := 'yuanxiang',
 '元興' := 'yuanxing',
 '元延' := 'yuanyan',
 '元祐' := 'yuanyou',
 '元貞' := 'yuanzhen',
 '玉衡' := 'yuheng',
 '玉恒' := 'yuheng',
 '載初' := 'zaichu',
 '章和' := 'zhanghe',
 '章武' := 'zhangwu',
 '昭寧' := 'zhaoning',
 '正大' := 'zhengda',
 '正德' := 'zhengde',
 '正光' := 'zhengguang',
 '征和' := 'zhenghe',
 '政和' := 'zhenghe',
 '正隆' := 'zhenglong',
 '正平' := 'zhengping',
 '證聖' := 'zhengsheng',
 '正始' := 'zhengshi',
 '正統' := 'zhengtong',
 '貞觀' := 'zhenguan',
 '正元' := 'zhengyuan',
 '禎明' := 'zhenming',
 '貞明' := 'zhenming',
 '真興' := 'zhenxing',
 '貞祐' := 'zhenyou',
 '貞元' := 'zhenyuan',
 '至大' := 'zhida',
 '至道' := 'zhidao',
 '至德' := 'zhide',
 '至和' := 'zhihe',
 '致和' := 'zhihe',
 '至寧' := 'zhining',
 '治平' := 'zhiping',
 '至順' := 'zhishun',
 '至元' := 'zhiyuan',
 '至正' := 'zhizheng',
 '至治' := 'zhizhi',
 '中和' := 'zhonghe',
 '重和' := 'zhonghe',
 '中平' := 'zhongping',
 '中統' := 'zhongtong',
 '重熙' := 'zhongxi',
 '中興' := 'zhongxing',
 '總章' := 'zongzhang',
 '大中祥符' := 'dazhongXiangfu',
 '福聖承道' := 'fushengChengdao',
 '建武中元' := 'jianwuZhongyuan',
 '建中靖國' := 'jianzhongJingguo',
 '乃馬真后' := 'naimaZhenhou',
 '順治' := 'shunzhi',
 '太平興國' := 'taipingXingguo',
 '太平真君' := 'taipingZhenjun',
 '天安禮定' := 'tiananLiding',
 '天冊萬歲' := 'tianceWansui',
 '天賜禮盛國慶' := 'tianciLichengGuoqing',
 '天授禮法延祚' := 'tianshouLifaYanzuo',
 '天儀治平' := 'tianyiZhiping',
 '天祐垂聖' := 'tianyouChuisheng',
 '天祐民安' := 'tianyouMinan',
 '萬歲登封' := 'wansuiDengfeng',
 '萬歲通天' := 'wansuiTongtian',
 '延嗣寧國' := 'yansiNingguo',
 '中大通' := 'zhongDatong',
 '中大同' := 'zhongDatong',
 '中華民國' := 'zhonghuaMinguo'
 }
 
 declare function local:org-add ($person as node()*, $inst as node()*) as node()* {
(:- person is c_personid, $inst is data table that holds c_person_id AND c_inst_code  :)
(:- This function returns the institution (orgName) that is linked to a certain posting, including its address. This is NOT necessarily the address of the posting itself.
 : Data on this aspect is still very sparse in 2014 
 : 
 : Switch to ZZZ query table here?
 : so far no end years in code table once they are added query needs a rewrite:) 


    for $person in $inst//c_personid[. =$person]/../c_inst_code[. > 0]
    
    let $dates := $SOCIAL_INSTITUTION_CODES//c_inst_code[. =$person]
    let $names := $SOCIAL_INSTITUTION_CODES//c_inst_name_code[. = $person/../c_inst_name_code]
    let $place := $ADDR_CODES//c_addr_id[. =$SOCIAL_INSTITUTION_ADDR//c_inst_code[. =$person]]
    
    return
        <orgName>
            {if ($dates/../c_inst_begin_year[. =0]) then ()
                else (<date notBefore="{local:isodate($dates/../c_inst_begin_year)}"/>)
            }
                <orgName xml:lang="zh-Latn-alalc97">{$names/../c_inst_name_py/text()}
                    <state>{$SOCIAL_INSTITUTION_TYPES//c_inst_type_code[. = $SOCIAL_INSTITUTION_CODES//c_inst_code[. =$person]/../c_inst_type_code]/../c_inst_type_py/text()}</state>
                </orgName>
                <orgName xml:lang="zh-Hant">{$names/../c_inst_name_hz/text()}
                    <state>{$SOCIAL_INSTITUTION_TYPES//c_inst_type_code[. = $SOCIAL_INSTITUTION_CODES//c_inst_code[. =$person]/../c_inst_type_code]/../c_inst_type_hz/text()}</state>
                </orgName>
            {if ($person/../c_posting_id[. > 0]) 
            then (<placeName ref="{concat("#PL", $place/../c_inst_addr_id/text())}">                   
                        <note>{$SOCIAL_INSTITUTION_ADDR_TYPES//c_inst_addr_type[. = $SOCIAL_INSTITUTION_ADDR//c_inst_code[. =$person]/../c_inst_addr_type]/../c_inst_addr_type_desc/text()}</note>
                        <note>{$SOCIAL_INSTITUTION_ADDR_TYPES//c_inst_addr_type[. = $SOCIAL_INSTITUTION_ADDR//c_inst_code[. =$person]/../c_inst_addr_type]/../c_inst_addr_type_desc_chn/text()}</note>
                    {if ($SOCIAL_INSTITUTION_ADDR//c_inst_code[. =$person]/../c_notes[. != '']) 
                    then (<note>{$SOCIAL_INSTITUTION_ADDR//c_inst_code[. =$person]/../c_notes/text()}</note>)
                    else()
                    }
                </placeName>)
            else()
            }
            {if ($SOCIAL_INSTITUTION_CODES//c_inst_code[. = $person]/../c_notes[. !='']) then (
            <note>{$SOCIAL_INSTITUTION_CODES//c_inst_code[. = $person]/../c_notes/text()}</note>)
            else()
            }
    </orgName>
};

(:Full source:)
{ if ($source) 
  then (<bibl>
            <ref target="{concat('#BIB', $source/../c_textid/text())}"/>
                {
                if (empty($source/../c_pages)) 
                then ()
                else(<biblScope unit="page">{$source/../c_pages/text()}</biblScope>)
                }
        </bibl>)
  else ()
}

(: let $count := count($global:BIOG_MAIN[c_personid])
 let $test := $global:BIOG_MAIN//c_personid

 for $i in 1 to $count idiv 1000 + 1
 let $collection := xmldb:create-collection("/db/apps/cbdb-data/target", concat('CBDB', $i))
 
 for $test in subsequence($count -1 *1000, )
 let $person := biog:biog($test, '')
 let $documentname := concat('CBDB', functx:pad-integer-to-length($test/text(), 7), '.xml')
 
 return xmldb:store($collection, $documentname, $person):)
 
(: 
let $persons := $data//listPerson/*
let $notes := $persons//note

(:Get the sum (and index positions) of all notes:)
let $seq := 1 to count($notes)



(:Set this variable to the desired number of note elements in each chunk:)
let $chunksize := 2
let $chunks :=
        (: map  positional index of note elements to chunks of desired size eg.
        for blocks with 50 notes
        $chunks(1) -> 1
        $chunks(50) -> 1
        $chunks(51) -> 2
        $chunks(2339) -> 47:)
        map:new (
                for $i at $count in $seq 
                return 
                    map:entry ($seq[$i],  round($count div $chunksize)), "?strength=primary"
                )

(:Determine if a node at the beginning of a chunk has siblings from the same person parent:)
let $firsts := for $i in $chunks[$i]
    return if (exists($notes[$i]/preceding-sibling::note)) then ($i= $i - 1)
    else($i)
    
let $last :=


(:Get the different starting positions for each block, make sure that it doesn't split the parent person element:)
for $i in $seq
let $start := $chunks($i) mod $chunksize =0 
(:select all notes from $start to $end:)
for $n at $count in subsequence($notes, $i, $chunksize)
group by $blocks := $chunks($count)

   return <listPerson n="{count($blocks)}-{count($count)}">
        {$n/ancestor-or-self::person}
        {count($n)}
    </listPerson>


:)

declare function pla:merge-place-dupes ($places as node()*) as item()*{
(:this function takes the place nodes to be merged and writes them into an aux file:)
let $dupes := xmldb:store($global:target, 'place-lookup.xml',
    <listPlace>
        {for $place in $global:ADDRESSES//c_addr_id
         where count($global:ADDRESSES//c_addr_id[. = $place]) > 1
         return
            pla:address($place)}
    </listPlace>)
    
let $dedupes :=  <listPlace>
                        {for $dupe in $dupes/listPlace/place
                        let $id := data($dupe/@xml:id)                 
                        return
                            <place xml:id="{data($dupe/@xml:id)}">
                                {functx:distinct-deep($dupes//place[@xml:id = $id]/*)}
                            </place>}
                     </listPlace>

return
    xmldb:store($global:target, 'place-dupe.xml',
    <tei:listPLace>{functx:distinct-deep($dedupes//place)}</listPLace>)
};

declare function pla:update-listPlace (){    

let $listPlace := doc(concat($global:target, $global:place))
let $dedupe := doc(concat($global:target, 'place-dedupe.xml'))

(:

dimitri's solution 
http://stackoverflow.com/questions/3875560/xquery-finding-duplciate-ids?rq=1

delete all dupes but the first

let $vSeq := $listPlace//place[@xml:id = data($dedupe//place/@xml:id)]
return
    update delete $vSeq[position() = index-of($vSeq, .)[. > 1]] 
    
    :)
    
let $vSeq := $listPlace//place[@xml:id = data($dedupe//place/@xml:id)]

for $n in $vSeq
let $m := $dedupe//place[@xml:id = data($n/@xml:id)]



return
    (update delete $vSeq[position() = index-of($vSeq, .)[. > 1]] ), (update replace $n with $m)
    };
    
declare function local:new-isodate ($string as xs:string?, $range as node()?)  as item() {

(:This function takes a date (mostly years) as $string input,
and the matching $range property from within the same table row.

Alas, range doesn't work that way so screw it. 

The attribute name is based on $global:YEAR_RANGE_CODES

It returns proper xs:gYear values for $string, inside $range attributes
ie.:

"0000", 4 digits, with leading "-" for BCE dates
   <a>-1234</a>    ----------> <gYear>-1234</gYear>
   <b/>    ------------------> <gYear/>
   <c>1911</c> --------------> <gYear>1911</gYear>
   <d>786</d>  --------------> <gYear>0786</gYear>
   
   according to <ref target="http://www.tei-c.org/release/doc/tei-p5-doc/en/html/ref-att.datable.w3c.html"/>
   "0000" should be "-0001" in TEI.   
:)
let $date := for $n in $string  
    return
         if (empty($string)) then ()
            else if (number($string) eq 0) then ('-0001')
                else if (starts-with($string, "-")) then (concat('-',(concat (string-join((for $i in (string-length(substring($string,2)) to 3) return '0'),'') , substring($string,2)))))
                    else (concat (string-join((for $i in (string-length($string) to 3) return '0'),'') , $string))
return
    switch ($range)
        case ('-1') return attribute notAfter {$date}
        case ('1') return attribute notBefore {$date}
        case ('2') return (attribute when {$date}, attribute cert {'medium'})
        case ('300') return (attribute from {'0960'}, attribute to {'1082'})
        case ('301') return (attribute from {'1082'}, attribute to {'1279'})
        default return attribute when {$date}   
};

declare function local:nest-places ($data as node()*, $id as node(), $zh as node()?, $py as node()?, $mode as xs:string?) as item()*{


    let $belong := $global:ADDR_BELONGS_DATA//no:c_addr_id[. = $id]   
    let $output :=   
        element place { 
            for $att in $id/../*[. != '0']
            order by local-name($att) 
            return
                typeswitch($att)
                    case element (no:c_addr_id) return attribute xml:id {concat('PL', $id/text())}
                    case element (no:c_admin_type) return attribute type {pla:fix-admin-types($att)}
                    case element (no:c_source) return attribute source {concat('#BIB', $att/text())}
                default return (),
                
            for $n in $id/../*
            order by local-name($n) descending
            return typeswitch($n) 
                case element (no:c_name_chn) return element placeName { attribute xml:lang {'zh-Hant'}, $zh/text()}
                case element (no:c_name) return element placeName { attribute xml:lang {'zh-Latn-alalc97'}, $py/text()}
                case element (no:c_alt_names) return element placeName { attribute type {'alias'}, $n/text()}
            default return (),                       
                     
            if (empty($id/../no:c_firstyear) and empty($id/../no:c_lastyear) and empty($id/../x_coord))
            then ()
            else ( element location {
                if (empty($id/../no:c_firstyear))
                then ()
                else ( attribute from {cal:isodate($id/../no:c_firstyear)}),
                
                if (empty($id/../no:c_lastyear))
                then ()
                else ( attribute to {cal:isodate($id/../no:c_lastyear)}),
                    
                if (empty($id/../no:x_coord) or $id/../no:x_coord[. = 0])
                then ()
                else (element geo {concat($id/../no:x_coord/text(), ' ', $id/../no:y_coord/text())})            
            }),
                     
                for $x in $id/../*[. !='0']
                order by local-name($x)
                return typeswitch($x)                
                    case element (no:CHGIS_PT_ID) return element idno { attribute type {'CHGIS'}, $x/text()}
                    case element (no:c_notes) return element note {$x/text()}               
                default return (),
                     
            if (empty($belong/../no:c_notes)) 
            then ()
            else (element note {$belong/../no:c_notes/text()}),             
            
            if (exists($data//no:c_belongs_to[. = $id/text()]))
            then (for $child in $data//no:c_belongs_to[. = $id/text()]
                   return 
                        pla:nest-places($data, $child/../no:c_addr_id, $child/../no:c_name_chn, $child/../no:c_name, ''))
            else ()            
        }
return 
    switch($mode)
        case 'v' return global:validate-fragment($output, 'place')
        case 'd' return global:validate-fragment($output, 'place')[1]
    default return $output       
       
};

let $dynasties := $config:DYNASTIES//no:row
let $hits :=

<hits>{
        for $dy in $dynasties/no:c_dy[. > '0']/../*
        return
            typeswitch ($dy)
                case element(no:c_dynasty_chn)
                    return
                        if ($wd-sparql//sr:literal[@xml:lang = 'zh'][. = $dy || '朝'] ne '')
                        then
                            (<best
                                n="{$dy/../no:c_dy}">{
                                    $dy || ' is ' ||
                                    substring-after($wd-sparql//sr:literal[@xml:lang = 'zh'][. = $dy || '朝']/../..//sr:uri, '/entity/') ||
                                    ' aka ' || $wd-sparql//sr:literal[@xml:lang = 'zh'][. = $dy || '朝']/text()
                                }</best>)
                        else
                            if ($wd-sparql//sr:literal[@xml:lang = 'zh'][. = $dy])
                            then
                                (<better
                                    n="{$dy/../no:c_dy}">{
                                        $dy || ' is ' ||
                                        substring-after($wd-sparql//sr:literal[@xml:lang = 'zh'][. = $dy]/../..//sr:uri, '/entity/') ||
                                        ' aka ' || $wd-sparql//sr:literal[@xml:lang = 'zh'][. = $dy]/text()
                                    }</better>)
                            else
                                if ($wd-sparql//sr:literal[@xml:lang = 'zh'][contains(., $dy)])
                                then
                                    (<good
                                        n="{$dy/../no:c_dy}">{
                                            $dy || ' should be ' ||
                                            substring-after($wd-sparql//sr:literal[@xml:lang = 'zh'][contains(., $dy)]/../..//sr:uri, '/entity/') ||
                                            ' aka ' || $wd-sparql//sr:literal[@xml:lang = 'zh'][contains(., $dy)]
                                        }</good>)
                                else
                                    ()
                case element(no:c_dynasty)
                    return
                        for $wd in $wd-sparql//sr:literal[@xml:lang = 'en']
                        return
                            if (lower-case($dy) || ' dynasty' eq lower-case($wd))
                            then
                                (<best_en
                                    n="{$dy/../no:c_dy}">{
                                        $dy/text() || ' is ' ||
                                        substring-after($wd/../..//sr:uri, '/entity/') ||
                                        ' aka ' || $wd/text()
                                    }</best_en>)
                            else
                                if (lower-case($dy) eq lower-case($wd))
                                then
                                    (<better_en
                                        n="{$dy/../no:c_dy}">{
                                            $dy/text() || ' is ' ||
                                            substring-after($wd/../..//sr:uri, '/entity/') ||
                                            ' aka ' || $wd/text()
                                        }</better_en>)
                                else
                                    if (contains(tokenize(lower-case($wd), '\s'), lower-case($dy)))
                                    then
                                        (<good_en
                                            n="{$dy/../no:c_dy}">{
                                                $dy/text() || ' should be ' ||
                                                substring-after($wd/../..//sr:uri, '/entity/') ||
                                                ' aka ' || $wd/text()
                                            }</good_en>)
                                    else
                                        ()
                default
                    return
                        ()
    }
</hits>
let $sorted :=
<sorted>{
        for $h in $hits/*
            order by local-name($h)
        return
            $h
    }</sorted>
    
let $map := map
 {5: 'wd#Q7405', 
6: 'wd#Q9683',
15: 'wd#Q7462',
16: 'wd#Q4958', 
17: 'wd#Q5066', 
18: 'wd#Q7313', 
19: 'wd#Q9903',
20: 'wd#Q8733', 
25: 'wd#Q1147037', 
27: 'wd#Q306928',
43: 'wd#Q7183', 
71: 'wd#Q169705', 
77: 'wd#Q35216'}    

let $look := for $n in $sorted/*
    order by number($n/@n)
return
distinct-values(
    <map>
        <id>{data($n/@n)}</id>
        <wb>{functx:get-matches($n/text(), 'Q[\d]+')}</wb>
    </map>)
    
return 
$sorted